# ============================================================================
# Workflow: Excel → JSON Automation
# Purpose : Automate scheduled and manual Excel-to-JSON updates, including
#           deletions, backups, and detailed run reports for the database.
# Version : 3.1 (Fix: Corrected report path detection)
# ============================================================================

name: Excel → JSON Update

on:
  # Allows you to manually trigger this workflow from the Actions tab in GitHub.
  workflow_dispatch:

  # Sets up a scheduled run. The cron syntax "30 18 * * 6" means it will run
  # at 18:30 UTC every Saturday. (This is 12:00 AM IST on Sunday).
  schedule:
    - cron: "30 18 * * 6"

jobs:
  update-json:
    # This sets a hard time limit for the entire job. If it runs longer than
    # 50 minutes, GitHub will automatically cancel it. This prevents runaway workflows
    # and enables our resumable workflow strategy.
    timeout-minutes: 50
    
    # The workflow will run on the latest version of Ubuntu provided by GitHub.
    runs-on: ubuntu-latest

    # These permissions are required for the workflow to perform specific actions:
    #   - contents: write --> Allows the job to commit changes back to your repository.
    permissions:
      contents: write

    steps:
      # ===================================================================
      #  STEP 1: SETUP & CONFIGURATION
      # ===================================================================
      - name: 1. Checkout repository
        # This action checks out your repository code, so the workflow can access
        # your script, requirements file, and other repo contents.
        uses: actions/checkout@v4

      - name: 2. Set up Python environment
        # Sets up a specific version of Python for the runner.
        # Using a specific version ensures the script runs consistently.
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: 3. Install Python dependencies
        # Reads the requirements.txt file and installs all the necessary Python
        # packages (like pandas, requests, etc.) using pip.
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: 4. Configure Google Drive & Excel Secrets
        # These steps securely write the secrets (stored in GitHub) into files.
        # The Python script reads these files to get the credentials it needs to
        # access your private Google Sheet without exposing them in the code.
        env:
          EXCEL_FILE_ID: ${{ secrets.EXCEL_FILE_ID }}
          GDRIVE_SERVICE_ACCOUNT: ${{ secrets.GDRIVE_SERVICE_ACCOUNT }}
        run: |
          set -euo pipefail
          echo "Writing secrets to temporary files..."
          printf '%s' "$EXCEL_FILE_ID" > EXCEL_FILE_ID.txt
          printf '%s' "$GDRIVE_SERVICE_ACCOUNT" > GDRIVE_SERVICE_ACCOUNT.json

      # ===================================================================
      #  STEP 2: EXECUTE THE PYTHON SCRIPT
      # ===================================================================
      - name: 5. Run the Excel-to-JSON update script
        # This is the main step where your Python script is executed.
        id: run_updater
        # continue-on-error: true --> Ensures that even if the script fails,
        # the subsequent steps (like sending a failure email) will still run.
        continue-on-error: true
        env:
          # IMPORTANT: Define which Excel sheets the script should process.
          # Separate multiple sheets with a semicolon (;).
          SHEETS: "Sheet1;Feb 7 2023 Onwards;Sheet2"
          # This tells the script whether the run was triggered by a schedule.
          SCHEDULED_RUN: ${{ github.event_name == 'schedule' }}
          # This passes your repo's GitHub Pages URL to the script so it can
          # create correct, absolute URLs for the show images.
          GITHUB_PAGES_URL: ${{ secrets.GITHUB_PAGES_URL }}
        run: |
          set -euo pipefail
          echo "Starting the Python script..."
          # Run the script and capture all its output (both standard and error) into a variable.
          output=$(python create_update_backup_delete.py 2>&1)
          
          # Print the captured output to the workflow log for debugging.
          printf '--- Script Output ---\n%s\n--- End Script Output ---\n' "$output"
          
          # This is a special syntax to save the multi-line script output
          # so it can be used in later steps (like the email body).
          echo "output_log<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          # [ THE FIX IS HERE ]
          # This command now correctly searches for the "Report written -> " text
          # that the Python script actually outputs. This ensures the step succeeds.
          report_path=$(echo "$output" | grep -oP 'Report written -> \K.*' || true)
          echo "Found report path: $report_path"
          echo "report_path=$report_path" >> "$GITHUB_OUTPUT"

      # ===================================================================
      #  STEP 3: COMMIT CHANGES TO THE REPOSITORY
      # ===================================================================
      - name: 6. Commit and push all generated files
        # This step will now run correctly because step 5 will succeed.
        # It saves all the work done by the script back to your repository.
        run: |
          set -euo pipefail
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "Adding generated files to the commit..."
          # Add all relevant generated files. --force ensures files are added even if gitignored.
          git add --force seriesData.json images/ backups/ reports/ deleted-data/ deleted-images/ backup-meta-data/ run_state.json || true
          
          # This checks if there are any actual changes to commit.
          if git diff --cached --quiet; then
            echo "No data changes to commit."
          else
            commit_message="Automated data update: $(date -u '+%Y-%m-%d %H:%M UTC')"
            echo "Creating commit: $commit_message"
            git commit -m "$commit_message"
            git push
          fi

      # ===================================================================
      #  STEP 4: NOTIFICATIONS & CLEANUP
      # ===================================================================
      - name: 7. Determine workflow final status
        # This step checks the outcome of the main script execution step.
        id: check_status
        if: always() # always() ensures this runs even if a previous step failed.
        run: |
          if [ "${{ steps.run_updater.outcome }}" = "success" ]; then
            echo "status=success" >> "$GITHUB_OUTPUT"
            echo "Workflow step succeeded."
          else
            echo "status=failure" >> "$GITHUB_OUTPUT"
            echo "Workflow step failed."
          fi

      - name: 8. Set dynamic email subject
        # Creates a clear, informative email subject based on the workflow's
        # trigger type (Manual/Automatic) and its final status (Success/Failure).
        id: set_subject
        if: always()
        run: |
          trigger_type=$([ "${{ github.event_name }}" = "schedule" ] && echo "[Automatic]" || echo "[Manual]")
          workflow_status="${{ steps.check_status.outputs.status }}"
          
          if [ "$workflow_status" = "failure" ]; then
            final_subject="[ACTION REQUIRED] $trigger_type Workflow FAILED"
          else
            subj_date=$(date -u -d '+5 hours 30 minutes' "+%d %B %Y")
            final_subject="$trigger_type Workflow $subj_date - Final Report"
          fi
          echo "email_subject=$final_subject" >> "$GITHUB_OUTPUT"

      - name: 9. Upload report as a workflow artifact
        # Saves the entire 'reports' directory as a downloadable artifact.
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: run-reports
          path: reports/
          if-no-files-found: warn # Won't fail the job if the reports folder is empty.

      - name: 10. Compose consolidated email body
        # Gathers all the relevant information into a single text file for the email body.
        id: compose_email
        if: always()
        env:
          REPORT_PATH: ${{ steps.run_updater.outputs.report_path }}
          WORKFLOW_STATUS: ${{ steps.check_status.outputs.status }}
          SCRIPT_OUTPUT: ${{ steps.run_updater.outputs.output_log }}
        run: |
          set -euo pipefail
          email_body_file=$(mktemp) # Creates a temporary file to store the body.
          {
            if [ "${WORKFLOW_STATUS}" = "failure" ]; then
              echo "❌ WORKFLOW FAILED"
              echo "The script encountered a fatal error. See the full script output below for details."
              echo "===================================================================="
              echo "$SCRIPT_OUTPUT"
              echo "===================================================================="
            fi
            
            report_file="${REPORT_PATH:-}"
            if [ ! -f "$report_file" ]; then
              report_file=$(ls -t reports/Report_*.txt 2>/dev/null | head -n1 || true)
            fi
            
            if [ -f "$report_file" ]; then
              echo "✅ SCRIPT LOG & REPORT"
              echo "===================================================================="
              cat "$report_file"
            else
              echo "⚠️ The main report file could not be found, showing raw output instead."
              echo "===================================================================="
              echo "$SCRIPT_OUTPUT"
            fi
          } > "$email_body_file"
          echo "body_file=$email_body_file" >> "$GITHUB_OUTPUT"

      - name: 11. Send consolidated report email
        # Uses a third-party action to send the composed email.
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: ${{ steps.set_subject.outputs.email_subject }}
          body: file://${{ steps.compose_email.outputs.body_file }}
          to: ${{ secrets.NOTIFY_EMAIL }}
          from: ${{ secrets.SMTP_USERNAME }}