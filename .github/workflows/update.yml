# ============================================================================
# Workflow: Excel → JSON Automation
# Purpose : Automate scheduled and manual Excel-to-JSON updates, including
#           deletions, backups, and detailed run reports for the database.
# Version : 3.2 (Fix: Implemented robust exit code checking)
# ============================================================================

name: Excel → JSON Update

on:
  workflow_dispatch:
  schedule:
    - cron: "30 18 * * 6"

jobs:
  update-json:
    timeout-minutes: 50
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      # ===================================================================
      #  STEP 1: SETUP & CONFIGURATION
      # ===================================================================
      - name: 1. Checkout repository
        uses: actions/checkout@v4

      - name: 2. Set up Python environment
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: 3. Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: 4. Configure Google Drive & Excel Secrets
        env:
          EXCEL_FILE_ID: ${{ secrets.EXCEL_FILE_ID }}
          GDRIVE_SERVICE_ACCOUNT: ${{ secrets.GDRIVE_SERVICE_ACCOUNT }}
        run: |
          set -euo pipefail
          echo "Writing secrets to temporary files..."
          printf '%s' "$EXCEL_FILE_ID" > EXCEL_FILE_ID.txt
          printf '%s' "$GDRIVE_SERVICE_ACCOUNT" > GDRIVE_SERVICE_ACCOUNT.json

      # ===================================================================
      #  STEP 2: EXECUTE THE PYTHON SCRIPT (IMPROVED & ROBUST)
      # ===================================================================
      - name: 5. Run the Excel-to-JSON update script
        id: run_updater
        continue-on-error: true
        env:
          SHEETS: "Sheet1;Feb 7 2023 Onwards;Sheet2"
          SCHEDULED_RUN: ${{ github.event_name == 'schedule' }}
          GITHUB_PAGES_URL: ${{ secrets.GDRIVE_SERVICE_ACCOUNT }}
        run: |
          # We remove 'set -e' to handle the exit code manually for better control.
          echo "Starting the Python script..."
          
          # This command runs the script and saves all its output to a file named 'output.log'.
          # The 'tee' command also prints the output to the console in real-time, which is great for debugging.
          python create_update_backup_delete.py 2>&1 | tee output.log
          
          # [ THE NEW ROBUST FIX IS HERE ]
          # We check the exit code of the first command in the pipeline (the python script).
          # PIPESTATUS is a special bash variable that holds the exit codes of all commands in the last pipeline.
          # This is the most reliable way to determine if YOUR script succeeded or failed.
          script_exit_code=${PIPESTATUS[0]}
          if [ "$script_exit_code" -ne 0 ]; then
            echo "::error::Python script failed with exit code $script_exit_code."
            exit 1 # Explicitly fail the step
          fi
          
          echo "Python script completed successfully. Processing output..."
          
          # Now that we know it succeeded, we safely process the output.
          output=$(cat output.log)
          echo "output_log<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          # This grep is now much safer because we only run it after confirming script success.
          report_path=$(echo "$output" | grep -oP 'Report written -> \K.*')
          echo "Found report path: $report_path"
          echo "report_path=$report_path" >> "$GITHUB_OUTPUT"

      # ===================================================================
      #  STEP 3: COMMIT CHANGES TO THE REPOSITORY
      # ===================================================================
      - name: 6. Commit and push all generated files
        if: steps.run_updater.outcome == 'success'
        run: |
          set -euo pipefail
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "Adding generated files to the commit..."
          git add --force seriesData.json images/ backups/ reports/ deleted-data/ deleted-images/ backup-meta-data/ run_state.json || true
          
          if git diff --cached --quiet; then
            echo "No data changes to commit."
          else
            commit_message="Automated data update: $(date -u '+%Y-%m-%d %H:%M UTC')"
            echo "Creating commit: $commit_message"
            git commit -m "$commit_message"
            git push
          fi

      # ===================================================================
      #  STEP 4: NOTIFICATIONS & CLEANUP
      # ===================================================================
      - name: 7. Determine workflow final status
        id: check_status
        if: always()
        run: |
          if [ "${{ steps.run_updater.outcome }}" = "success" ]; then
            echo "status=success" >> "$GITHUB_OUTPUT"
          else
            echo "status=failure" >> "$GITHUB_OUTPUT"
          fi

      - name: 8. Set dynamic email subject
        id: set_subject
        if: always()
        run: |
          trigger_type=$([ "${{ github.event_name }}" = "schedule" ] && echo "[Automatic]" || echo "[Manual]")
          workflow_status="${{ steps.check_status.outputs.status }}"
          if [ "$workflow_status" = "failure" ]; then
            final_subject="[ACTION REQUIRED] $trigger_type Workflow FAILED"
          else
            subj_date=$(date -u -d '+5 hours 30 minutes' "+%d %B %Y")
            final_subject="$trigger_type Workflow $subj_date - Final Report"
          fi
          echo "email_subject=$final_subject" >> "$GITHUB_OUTPUT"

      - name: 9. Upload report as a workflow artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: run-reports
          path: reports/
          if-no-files-found: warn

      - name: 10. Compose consolidated email body
        id: compose_email
        if: always()
        env:
          REPORT_PATH: ${{ steps.run_updater.outputs.report_path }}
          WORKFLOW_STATUS: ${{ steps.check_status.outputs.status }}
          SCRIPT_OUTPUT: ${{ steps.run_updater.outputs.output_log }}
        run: |
          set -euo pipefail
          email_body_file=$(mktemp)
          {
            if [ "${WORKFLOW_STATUS}" = "failure" ]; then
              echo "❌ WORKFLOW FAILED"
              echo "The script encountered a fatal error. See the full script output below for details."
              echo "===================================================================="
              echo "$SCRIPT_OUTPUT"
              echo "===================================================================="
            fi
            
            report_file="${REPORT_PATH:-}"
            if [ ! -f "$report_file" ]; then
              report_file=$(ls -t reports/Report_*.txt 2>/dev/null | head -n1 || true)
            fi
            
            if [ -f "$report_file" ]; then
              echo "✅ SCRIPT LOG & REPORT"
              echo "===================================================================="
              cat "$report_file"
            else
              echo "⚠️ The main report file could not be found, showing raw output instead."
              echo "===================================================================="
              echo "$SCRIPT_OUTPUT"
            fi
          } > "$email_body_file"
          echo "body_file=$email_body_file" >> "$GITHUB_OUTPUT"

      - name: 11. Send consolidated report email
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: ${{ steps.set_subject.outputs.email_subject }}
          body: file://${{ steps.compose_email.outputs.body_file }}
          to: ${{ secrets.NOTIFY_EMAIL }}
          from: ${{ secrets.SMTP_USERNAME }}